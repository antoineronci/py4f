# -*- coding: utf-8 -*-
"""ARIMA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h19UGP8UiO4QOCY2zunrIVWhL_O9ShKt
"""

!pip install --user statsmodels

# Commented out IPython magic to ensure Python compatibility.
#import librairies

# %matplotlib inline

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import datetime


# %config InlineBackend.figure_format = 'retina'

#Get the data

df = pd.read_csv('/content/AUDUSD=X.csv')

df['Date'] = pd.to_datetime(df['Date'])
df.sort_values('Date', inplace=True)
df.set_index('Date', inplace=True)



print(df.shape)

df.head()



"""# Prepare data for ARIMA"""

#Agregate data on a weekly basis
df_week = df.resample('w').mean()
df_week = df_week[['Close']]
df_week.head()

#Create a column for weekly returns to normalize large fluctuations.
df_week['Weekly_ret'] = np.log(df_week['Close']).diff()

#Drop null rows
df_week.dropna(inplace=True)
df_week.head()

df_week.Weekly_ret.plot(kind='line', figsize=(12, 6));

udiff = df_week.drop(['Close'], axis=1)
udiff.head()

"""#Test for stationarity of the udiff series"""

import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller

rolmean = udiff.rolling(20).mean()
rolstd = udiff.rolling(20).std()

plt.figure(figsize=(12, 6))
orig = plt.plot(udiff, color='blue', label='Original')
mean = plt.plot(rolmean, color='red', label='Rolling Mean')
std = plt.plot(rolstd, color='black', label = 'Rolling Std Deviation')
plt.title('Rolling Mean & Standard Deviation')
plt.legend(loc='best')
plt.show(block=False)

# Perform Dickey-Fuller test 
# With a p-value < 0.05, we can reject the null hypotehsis, so the data set is stationary 
dftest = sm.tsa.adfuller(udiff.Weekly_ret, autolag='AIC')
dfoutput = pd.Series(dftest[0:4], index=['Test Statistic', 'p-value', '#Lags Used', 'Number of Observations Used'])
for key, value in dftest[4].items():
    dfoutput['Critical Value ({0})'.format(key)] = value
    
dfoutput

"""# ACF and PACF Charts"""

#Making autocorrelation and partial autocorrelation charts help us choose hyperparameters for the ARIMA model.
#The ACF gives us a measure of how much each "y" value is correlated to the previous n "y" values prior.
#The PACF is the partial correlation function gives us (a sample of) the amount of correlation between two "y" values separated by n lags excluding the impact of all the "y" values in between them.

from statsmodels.graphics.tsaplots import plot_acf

fig, ax = plt.subplots(figsize=(12,5))
plot_acf(udiff.values, lags=10, ax=ax)
plt.show()

from statsmodels.graphics.tsaplots import plot_pacf

fig, ax = plt.subplots(figsize=(12,5))
plot_pacf(udiff.values, lags=10, ax=ax)
plt.show()

"""#Build ARIMA model"""

#Since we differenced the weekly closing prices, we technically only need to build an ARMA model.
#The data has already been integrated and is stationary.

#The way to evaluate the model is to look at AIC - see if it reduces or increases. 
#The lower the AIC (i.e. the more negative it is), the better the model.

from statsmodels.tsa.arima_model import ARMA

ar1 = ARMA(tuple(udiff.values), (9, 1)).fit()
ar1.summary()

plt.figure(figsize=(12, 8))
plt.plot(udiff.values, color='blue')
preds = ar1.fittedvalues
plt.plot(preds, color='red')
plt.show()

#Prediction for next week close

steps = 1

forecast = ar1.forecast(steps=steps)[0]
print(forecast)
plt.figure(figsize=(12, 8))
plt.plot(udiff.values, color='blue')

preds = ar1.fittedvalues
plt.plot(preds, color='red')

plt.plot(pd.DataFrame(np.array([preds[-1],forecast[0]]).T,index=range(len(udiff.values)+1, len(udiff.values)+3)), color='green')
plt.plot(pd.DataFrame(forecast,index=range(len(udiff.values)+1, len(udiff.values)+1+steps)), color='green')
plt.title('Display the predictions with the ARIMA model')
plt.show()

week_price_prediction = np.exp(forecast)*df_week['Close'][-1]
print('Next week price will be:', week_price_prediction)