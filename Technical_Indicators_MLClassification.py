# -*- coding: utf-8 -*-
"""Technical_Indicators.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TATTFRYe9nUEj-bbI_tMLapVO-zJ4vJs

# Librairies
"""

!pip install --user statsmodels
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller
import fix_yahoo_finance as yf
import datetime as dt
import pandas as pd
from pandas_datareader import data as pdr
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import matplotlib.ticker as mticker
import datetime as datetime
import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import validation_curve
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import learning_curve
from sklearn import svm, model_selection, neighbors 
from sklearn.ensemble import VotingClassifier, RandomForestClassifier

"""# Create StockdataFrame with indicators"""

yf.pdr_override() #activate yahoo finance workaround

smasUsed=[7,20,50] 

start =dt.datetime(1990,1,1)- dt.timedelta(days=max(smasUsed)) 
now = dt.datetime.now() #Sets end point of dataframe
#stock = input("Enter the stock symbol : ") #Asks for stock ticker
stock='MSFT'
#while stock != "quit": #Runs this loop until user enters 'quit' (can do many stocks in a row)

stockData = pdr.get_data_yahoo(stock, start, now) #Fetches stock price data, saves as data frame
print(stockData.head())
stockData['RSI']=0
stockData['EMAslow']=0
stockData['EMAfast']=0
stockData['MACDsignal']=0

#Calculate moving averages
def MovingAverage(values,window):
  stockData['SMA_'+str(window)] = stockData.iloc[:,4].rolling(window).mean()
  return stockData['SMA_'+str(window)]
  

#calculate Bollinger Bands #stockPrice=stockData.iloc[:,4]
def BollingerBands(stockPrice,BBperiod,stdevCoefficient):
  stockData['SMA_'+str(BBperiod)] = stockPrice.rolling(window=BBperiod).mean() 
  stockData['STDEV']=stockPrice.rolling(window=BBperiod).std() 
  stockData['LowerBand']=stockData['SMA_'+str(BBperiod)]-(stdevCoefficient*stockData['STDEV']) 
  stockData['UpperBand']=stockData['SMA_'+str(BBperiod)]+(stdevCoefficient*stockData['STDEV']) 
    

  
 
#Calculate 10.4.4 stochastic# Period=14 K=4 D=4
def stochastic(Period,K,D):
  stockData["RolHigh"] = stockData["High"].rolling(window=Period).max() #Finds high of period
  stockData["RolLow"] = stockData["Low"].rolling(window=Period).min() #finds low of period
  stockData["stok"] = ((stockData["Close"]-stockData["RolLow"])/(stockData["RolHigh"]-stockData["RolLow"]))*100 #Finds 10.1 stoch
  stockData["K"] = stockData["stok"].rolling(window=K).mean() #Finds 10.4 stoch
  stockData["D"] = stockData["K"].rolling(window=D).mean() #Finds 10.4.4 stoch
  
#Calculate RSI #preference : n=14
def rsiFunc(stockPrice, n):
  deltas = np.diff(stockPrice)
  seed = deltas[:n+1]
  up = seed[seed>=0].sum()/n
  down = -seed[seed<0].sum()/n
  rs = up/down
  rsi = np.zeros_like(stockPrice)
  rsi[:n]= 100. - 100./(1.+rs)

  for i in range(n, len(stockPrice)):
    delta = deltas[i-1]
    if delta >0:
      upval = delta
      downval = 0.
    else:
      upval = 0
      downval = -delta
    
    up = (up*(n-1)+upval)/n
    down = (down*(n-1)+downval)/n

    rs = up/down
    rsi[i] = 100. - 100./(1.+rs)

  for i in range(len(rsi)):
    stockData['RSI'][-i-1]= rsi[-i-1]

  return stockData['RSI'] 

#Exponential moving average
def ExpMovingAverage(stockPrice,window):
  weights = np.exp(np.linspace(-1.,0.,window))
  weights /= weights.sum()
  a = np.convolve(stockPrice,weights,mode='full')[:len(stockPrice)]
  a[:window] = a[window]
  return a

#MACD #Preference : slow=26 fast=12
def macdFunc(stockPrice, slow, fast):
  '''
  macd line = 12ema - 26ema
  ###signal line = 9ema of the macd line
  histogram = macd line - signal line
  '''
  x = ExpMovingAverage(stockPrice, slow)
  y = ExpMovingAverage(stockPrice, fast)
  z = ExpMovingAverage(stockPrice, 9)
  for i in range(len(x)):
    stockData['EMAslow'][i-1]=x[i-1]
    stockData['EMAfast'][i-1]=y[i-1]
    stockData['MACDsignal'][i-1]=z[i-1]
  stockData['MACD'] = stockData['EMAfast']-stockData['EMAslow']
  return stockData['EMAslow'], stockData['EMAfast'],stockData['MACDsignal'], stockData['MACD'] 



MovingAverage(stockData.iloc[:,4],50)
BollingerBands(stockData.iloc[:,4],20,2)
stochastic(14,1,3)
rsiFunc(stockData.iloc[:,4], 14)
macdFunc(stockData.iloc[:,4], 26, 12)

stockData=stockData.iloc[max(smasUsed):]






#stock = input("Enter the stock symbol : ") #Asks for new stock

"""# Pre-Processing the data"""

#Pre normalize data. ### ON PEUT SUREMENT UTILISER LE LOG ###

dataset = stockData

dataset['%1dClose'] = (dataset['Close']-dataset['Close'].shift(-1))/dataset['Close'].shift(-1)
dataset['%2dClose'] = (dataset['Close']-dataset['Close'].shift(-2))/dataset['Close'].shift(-1)
dataset['%3dClose'] = (dataset['Close']-dataset['Close'].shift(-3))/dataset['Close'].shift(-1)
dataset['%4dClose'] = (dataset['Close']-dataset['Close'].shift(-4))/dataset['Close'].shift(-1)
dataset['%5dClose'] = (dataset['Close']-dataset['Close'].shift(-5))/dataset['Close'].shift(-1)
dataset['%6dClose'] = (dataset['Close']-dataset['Close'].shift(-6))/dataset['Close'].shift(-1)
dataset['Volume'] = (dataset['Volume'] - dataset['Volume'].shift(-1))/dataset['Volume'].shift(-1)
dataset['STDEV'] = (dataset['STDEV'] - dataset['STDEV'].shift(-1))/dataset['STDEV'].shift(-1)
dataset['SMA_50'] = (dataset['SMA_50'] - dataset['SMA_50'].shift(-1))/dataset['SMA_50'].shift(-1)
dataset['EMAslow'] = (dataset['EMAslow'] - dataset['EMAslow'].shift(-1))/dataset['EMAslow'].shift(-1)
dataset['EMAfast'] = (dataset['EMAfast'] - dataset['EMAfast'].shift(-1))/dataset['EMAfast'].shift(-1)
#dataset['LowerBand'] = (dataset['LowerBand'] - dataset['LowerBand'].shift(-1))/dataset['LowerBand'].shift(-1)
#dataset['UpperBand'] = (dataset['UpperBand'] - dataset['UpperBand'].shift(-1))/dataset['UpperBand'].shift(-1)
dataset['MACDsignal'] = (dataset['MACDsignal'] - dataset['MACDsignal'].shift(-1))/dataset['MACDsignal'].shift(-1)
dataset = dataset.dropna(axis = 0, how = 'any')
dataset = dataset.replace([np.inf, -np.inf], 0)

#create BUYorSELL signal
dataset.loc[dataset['%1dClose'] >= 0,'BUYorSELL'] = 1     #BUY signal:1 <=> %change>0
dataset.loc[dataset['%1dClose'] < 0,'BUYorSELL'] = 0      #SELL signal:0 <=> %change<0

#shift(-1) for 1day forward BUYorSELL signal prediction 
dataset['BUYorSELL'] = dataset['BUYorSELL'].shift(-1)
dataset.dropna(inplace=True)

#Create a dataframe with normalized data

#elements=[]

for column in dataset.columns:  
  stdev=dataset['{}'.format(column)].std()
  mean=dataset['{}'.format(column)].mean()
  dataset['normalize_{}'.format(column)]=(dataset['{}'.format(column)]-mean)/stdev
  #elements.append(str('normalize_{}'.format(column)))
  dataset['normalize_{}'.format(column)].plot(kind='line', figsize=(12, 6))

#split Data

X = dataset.filter(['STDEV','%1dClose','%2dClose','%3dClose','%4dClose','%5dClose','%5dClose','normalize_Volume','normalize_RSI','normalize_MACDsignal', 'normalize_stok', 'normalize_K', 'normalize_D', 'normalize_MACD', 'EMAslow','EMAfast','normalize_SMA_50', 'normalize_LowerBand',
       'normalize_UpperBand'])

y = dataset.filter(['BUYorSELL']).values.ravel()

print(y)

"""# Machine Learning ClassificationModel"""

#Split the data 

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=5)

#Cross Validation 
#augmenter cv??=nombre de crossvalidation
#Validation Curve 
#model1=KNeighborsClassifier()
#k = np.arange(1,50)

#train_score, val_score = validation_curve(model1, X_train, y_train,'n_neighbors',k,cv=6)

#plt.plot(k,val_score.mean(axis=1), label='validation')
#plt.plot(k, train_score.mean(axis=1), label='train')
#plt.ylabel('score')
#plt.xlabel('n_neighbors')
#plt.legend()

clf = VotingClassifier([('lsvc', svm.LinearSVC()),
                        ('knn', neighbors.KNeighborsClassifier()),
                        ('rfor', RandomForestClassifier())])

clf.fit(X_train,y_train)
#Find the best combination for n_neighbors and metric distance calculation
#param_grid = {'n_neighbors': np.arange(1,20),
#              'metric':['euclidean','manhattan','minkowski']}
#grid = GridSearchCV(KNeighborsClassifier(),param_grid, cv=10)
#grid.fit(X_train,y_train)
#grid.best_score_
#grid.best_params_
#model = grid.best_estimator_
clf.score(X_test,y_test)

#Autre outil de mesure : Confusion Matrix
#N, train_score, val_score = learning_curve(clf, X_train, y_train, train_sizes = np.linspace(0.1, 1.0, 10), cv=10)
#plt.plot(N, train_score.mean(axis=1), label='train')
#plt.plot(N, val_score.mean(axis=1), label='validation')
#plt.xlabel('train_sizes')
#plt.legend()






